<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Paxos Basics | Bean Boat</title>
<meta name="generator" content="Jekyll v4.3.1">
<meta property="og:title" content="Paxos Basics">
<meta name="author" content="Minmin Jin">
<meta property="og:locale" content="en_US">
<meta name="description" content="This post is mostly based on the Paxos lecture video by John Ousterhout, and Paxos Made Moderately Complex.">
<meta property="og:description" content="This post is mostly based on the Paxos lecture video by John Ousterhout, and Paxos Made Moderately Complex.">
<link rel="canonical" href="http://localhost:4000/2022/08/07/paxos-basics.html">
<meta property="og:url" content="http://localhost:4000/2022/08/07/paxos-basics.html">
<meta property="og:site_name" content="Bean Boat">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2022-08-07T00:00:00-07:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Paxos Basics">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Minmin Jin"},"dateModified":"2022-08-07T00:00:00-07:00","datePublished":"2022-08-07T00:00:00-07:00","description":"This post is mostly based on the Paxos lecture video by John Ousterhout, and Paxos Made Moderately Complex.","headline":"Paxos Basics","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2022/08/07/paxos-basics.html"},"url":"http://localhost:4000/2022/08/07/paxos-basics.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="shortcut icon" href="favicon.png">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/assets/css/main.css">
  <script src="/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/atom.xml" title="Bean Boat">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/go.min.js"></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightBlock(block);
  }

  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    border-radius: 0 2px;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
</head>
<body>





































































































































<header class="site-header " role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<span class="site-brand"><a class="site-brand-inner" rel="author" href="/">
  <img class="site-favicon" title="Bean Boat" src="favicon.png" onerror="this.style.display='none'">
  Bean Boat
</a>
</span><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">
<a class="page-link" href="/">HOME</a><a class="page-link" href="/archives.html">ARCHIVES</a><a class="page-link" href="/tags.html">TAGS</a><!---->
            <!--




-->
            <!---->
            <!--<span class="page-link">

<div id="google_translate_element" style="display: none;">
</div>

<span class="ct-language">
  <ul class="list-unstyled ct-language-dropdown">
    
      <li>
        <a href="#" class="lang-select" data-lang="en">
          
          <img src="https://cdn.countryflags.com/thumbs/united-states-of-america/flag-400.png" title="English">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="fr">
          
          <img src="https://cdn.countryflags.com/thumbs/france/flag-400.png" title="French">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="zh-CN">
          
          <img src="https://cdn.countryflags.com/thumbs/china/flag-400.png" title="Chinese(Simple)">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ja">
          
          <img src="https://cdn.countryflags.com/thumbs/japan/flag-400.png" title="Japanese">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ko">
          
          <img src="https://cdn.countryflags.com/thumbs/south-korea/flag-400.png" title="Korean">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ru">
          
          <img src="https://cdn.countryflags.com/thumbs/russia/flag-400.png" title="Russian">
          
        </a>
      </li>
    
  </ul>
</span>

<script type="text/javascript">
function googleTranslateElementInit() {
  new google.translate.TranslateElement({
    pageLanguage: '',
    autoDisplay: false,
    layout: google.translate.TranslateElement.InlineLayout.VERTICAL
  }, 'google_translate_element');

  function restoreLang() {
    var iframe = document.getElementsByClassName('goog-te-banner-frame')[0];
    if (!iframe) return;

    var innerDoc = iframe.contentDocument || iframe.contentWindow.document;
    var restore_el = innerDoc.getElementsByTagName("button");

    for (var i = 0; i < restore_el.length; i++) {
      if (restore_el[i].id.indexOf("restore") >= 0) {
        restore_el[i].click();
        var close_el = innerDoc.getElementsByClassName("goog-close-link");
        close_el[0].click();
        return;
      }
    }
  }

  function triggerHtmlEvent(element, eventName) {
    var event;
    if (document.createEvent) {
      event = document.createEvent('HTMLEvents');
      event.initEvent(eventName, true, true);
      element.dispatchEvent(event);
    } else {
      event = document.createEventObject();
      event.eventType = eventName;
      element.fireEvent('on' + event.eventType, event);
    }
  }

  var googleCombo = document.querySelector("select.goog-te-combo");
  var langSelect = document.querySelector('.ct-language');
  langSelect.addEventListener('click', function(event) {
    if (!event.target) {
      return;
    }

    var selected = document.querySelector('.ct-language .ct-language-selected');
    if (selected) {
      selected.classList.remove('ct-language-selected');
    }

    var target = event.target;
    while (target && target !== langSelect ) {
      if (target.matches('.lang-select')) {
        break;
      }
      target = target.parentElement;
    }

    if (target && target.matches('.lang-select')) {
      var lang = target.getAttribute('data-lang');
      if (googleCombo.value == lang) {
        restoreLang();
      } else {
        target.parentElement.classList.add('ct-language-selected');
        googleCombo.value = lang;
        triggerHtmlEvent(googleCombo, 'change');
      }
    }

    event.preventDefault();
  });
}
</script>

<script type="text/javascript" src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
</span>-->
          </div>
        </nav>
</div>
  </div>
</header>

<script>
  (function() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;documentElement.setAttribute("data-header-transparent", "");var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  })();
</script>


























































































































































<script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    hashValue = decodeURIComponent(hashValue);
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = element.offsetTop - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('manual' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

    <div class="post-content e-content" itemprop="articleBody">

      <p>This post is mostly based on the <a href="https://www.youtube.com/watch?v=JEpsBg0AO6o">Paxos lecture video</a> by John Ousterhout, and <a href="https://paxos.systems">Paxos Made Moderately Complex</a>.</p>

<p>Paxos is a protocol for state machine replication in an asynchronous environment to reach consensus on single values. The failure model of a replica in an asynchronous environment includes non-<a href="https://en.wikipedia.org/wiki/Byzantine_fault">Byzantine</a> fail-stop, delayed or lost messages. The goal is to make the state machines reliable by executing the same commands in the order order on all servers, so in the event of failures, the states do not get lost. The challenge comes up when multiple clients issue requests to replicas in parallel. Different replicas may receive requests in different orders and execute the commands in different order, causing their local states to diverge from one another over time.</p>

<p>The problem can be modeled as having a sequence of slots with commands. The commands are stored as log entries and are executed in the state machines in the order of their slot index. Replicas receive requests from clients and assign them to specific slots. In the case of concurrent requests, a consensus protocol is used to choose a single command for the same slot from the different proposals from the replicas. A replica awaits for the decision before actually updating the sequence of commands, executing the next command, and sending back a response to the client.</p>

<h2 id="basic-paxos-single-decree">Basic Paxos (“single decree”)</h2>
<p>The basic idea of Basic Paxos is to have one or more servers propose values, and pick one <strong>single value</strong> as <strong>chosen</strong>. The term “consensus problem” typically refers to this single-value formulation.</p>

<h3 id="requirements">Requirements</h3>
<p>There are two requirements for Basic Paxos, safety and liveness.</p>
<ul>
  <li>
<strong>Safety</strong>
    <ul>
      <li>Only a single value may be chosen.</li>
      <li>A server never learns that a value has been chosen unless it really has been.</li>
    </ul>
  </li>
  <li>
<strong>Liveness</strong> (assuming majority of servers are up and communicating within reasonable timelines)
    <ul>
      <li>Some proposed value is eventually chosen.</li>
      <li>If a value is chosen, servers eventually learn about it.</li>
    </ul>
  </li>
</ul>

<h3 id="components">Components</h3>

<p>There are two components that work together to implement the algorithm.</p>
<ul>
  <li>
<strong>Proposers</strong>: handles client requests; and actively proposes values to be chosen.</li>
  <li>
<strong>Acceptors</strong>: passively responds to messages from proposers by voting yes or no, which forms the consensus. They want to know which value was chosen so they can pass it to the state machine. They store the chosen value and the state of the decision process.</li>
</ul>

<p>Optionally, there could be a third component called <strong>listeners</strong>, who would like to know the chosen value. They can be merged to the acceptors.</p>

<h3 id="thought-process">Thought process</h3>

<p>If we only have one single acceptor, it could crash and lose the chosen value. So it is better to have multiple acceptors and the value will be chosen if it is accepted by majority of acceptors, i.e. using quorum.</p>

<p>If acceptors accept only first value they receive, in the event of simultaneous proposals, no value might be chosen. Think of the case when each acceptor receives a different proposal. Therefore, acceptors must sometimes accept multiple different values.</p>

<p>If acceptors accept every value it receives, multiple values could be chosen, which violates the safety requirement. Therefore, once a value has been chosen, future proposals must propose or choose that same value. Imagine a situation when a proposal is issued but delayed, and a new proposal arrives and is accepted. There must be a way to reject the old first proposal. So we need a way to order the proposals.</p>

<h3 id="proposal-numbers">Proposal numbers</h3>

<p>The way to order proposals is to assign a unique number to each proposal. Higher numbers take priority over lower numbers. One simple approach is to concatenate two values. The lower bits is the server id, which is unique per server. This makes sure no two server generate the same proposal number. The higher bits is a max round number that is the largest that a server has ever seen. Servers track the round number and increment it to generate a new proposal number. Proposers must persist the max round number on disk, so they do not reuse it in case of crash or restart.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Proposal number = |Round Number|Server Id|
</code></pre></div></div>

<h3 id="flow">Flow</h3>

<p>The flow of Basic Paxos looks like below. Acceptors must record minProposal, acceptedProposal, and acceptedValue on stable storage.</p>
<ul>
  <li>Proposer
    <ul>
      <li>Choose a new proposal number n</li>
      <li>Broadcast <code class="language-plaintext highlighter-rouge">Prepare(n)</code> to a majority (or all) of Acceptors</li>
    </ul>
  </li>
  <li>Acceptor
    <ul>
      <li>Receive <code class="language-plaintext highlighter-rouge">Prepare(n)</code>
</li>
      <li>If n &gt; minProposal then minProposal = n, and accept the value. Otherwise, reject the value.</li>
      <li>Return(acceptedProposal, acceptedValue)</li>
    </ul>
  </li>
  <li>Proposer
    <ul>
      <li>Receive responses from majority</li>
      <li>If any acceptedValues returned, replace value with acceptedValue for highest acceptedProposal</li>
      <li>Broadcast <code class="language-plaintext highlighter-rouge">Accept(n, value)</code> to a majority (or all) Acceptors</li>
    </ul>
  </li>
  <li>Acceptor
    <ul>
      <li>Respond to <code class="language-plaintext highlighter-rouge">Accept(n, value)</code>:</li>
      <li>If n &gt;= minProposal then:
        <ul>
          <li>acceptedProposal = minProposal = n</li>
          <li>acceptedValue = value</li>
        </ul>
      </li>
      <li>Return(minProposal)</li>
    </ul>
  </li>
  <li>Proposer
    <ul>
      <li>Responses received from majority:
        <ul>
          <li>Any rejections (result &gt; n) ? goto(1)</li>
          <li>Otherwise, value is chosen</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="problems-of-basic-paxos">Problems of Basic Paxos</h3>

<p>There are several problems with Basic Paxos. One is that competing proposers may cause livelock. One solution is to have randomized delay before restarting, which gives other proposers a chance to finish choosing. Multi-Paxos will use leader election instead.</p>

<p>The other one is that only the proposer knows which value has been chosen. If other servers want to know, must execute Paxos with their own proposal.</p>

<h2 id="multi-paxos">Multi-Paxos</h2>

<p>Multi-Paxos combines several instances of Basic Paxos to agree on a series of values forming the log. It uses separate Basic Paxos for each slot in the log. To do this, we add <code class="language-plaintext highlighter-rouge">index</code> argument to <code class="language-plaintext highlighter-rouge">Prepare</code> and <code class="language-plaintext highlighter-rouge">Accept</code>. The lifecycle of a request looks like below:</p>
<ol>
  <li>Client sends command to server.</li>
  <li>Server uses Paxos to choose command as value for a slot of the log.</li>
  <li>Server returns result from state machine to client.</li>
  <li>Server waits for previous log entries to be applied, then applies new command to state machine.</li>
</ol>

<h3 id="choosing-a-slot-for-a-given-client-request">Choosing a slot for a given client request</h3>

<p>When a request arrives from client, replica first finds the first slot that is not known to be chosen (i.e. decision has not been made for this slot), then it runs Basic paxos to propose client’s command for this slot. If a <code class="language-plaintext highlighter-rouge">Prepare</code> returns acceptedValue, meaning the slot has been chosen for other replicas, it updates the slot with the acceptedValue and start again; Otherwise, the replica chooses the client’s command.</p>

<p>Replicas can handle multiple client requests concurrently, by selecting different slots for each. However, when it comes to the state machine, the commands must be passed to the state machine in the order of the slot.</p>

<h3 id="performance-optimization">Performance optimization</h3>

<p>Basic Paxos is inefficient because it allows multiple concurrent proposers, and thus conflicts and restarts are likely to happen, which causes higher load, leading to even more conflicts. Also, for each chosen value, 2 round of RPCs (Prepare and Accept) are needed.</p>

<h4 id="pick-a-leader">Pick a leader</h4>

<p>To solve the first issue, we can limit only one server as the proposer, which makes the server a <strong>leader</strong>. One simple approach to elect a leader from Lamport is to let the server with the highest id act as the leader. Each server sends a heartbeat message to every other server every T ms. If a server hasn’t received heartbeat from server with higher ID in last 2T ms, it acts as leader. A leader accepts requests from client and acts as proposer and acceptor. Other servers reject client requests or redirect them to the leader, and act only as acceptor.</p>

<h4 id="eliminate-most-prepare-rpcs">Eliminate most Prepare RPCs</h4>

<p>Prepare RPCs are needed for Basic Paxos to block old proposals and find out about possibly chosen values. To eliminate the Prepare RPC, we can make the proposal number refer to the entire log, and let acceptors return the highest proposal number that is accepted for the current slot. Acceptors will also return a <code class="language-plaintext highlighter-rouge">noMoreAccepted</code> bool to indicate if no proposals are accepted for any slot beyond the current one.</p>

<p>If acceptor responds to Prepare with <code class="language-plaintext highlighter-rouge">noMoreAccepted</code>, the leader skips future Prepares with that acceptor (until Accept rejected). Once the leader receives <code class="language-plaintext highlighter-rouge">noMoreAccepted</code> from majority of acceptors, no need for Prepare RPCs. With this, most log entries can be chosen in a single round of RPCs.</p>

<h3 id="ensuring-full-disclosure">Ensuring full disclosure</h3>

<p>So far, information is incomplete. Log entries are only replicated to the majority, and only proposer knows when entry is chosen. We want servers to be fully replicated, and be aware of the chosen value so that they can pass it to the state machine. The steps to achieve the goals are:</p>
<ul>
  <li>Keep retrying Accept RPCs until all acceptors respond (in background). This will fully replicates most entries.</li>
  <li>Mark entries that are known to be chosen with a special value. Each server maintains a <code class="language-plaintext highlighter-rouge">firstUnchosenIndex</code> index, which is the earliest log entry not marked as chosen.</li>
  <li>Proposer includes its <code class="language-plaintext highlighter-rouge">firstUnchosenIndex</code> in Accept RPCs. Acceptor marks all entries i chosen if <code class="language-plaintext highlighter-rouge">i &lt; request.firstUnchosenIndex</code> and <code class="language-plaintext highlighter-rouge">acceptedProposal[i] == request.proposal</code>. This makes acceptors know about most chosen entries.</li>
  <li>Acceptor returns its <code class="language-plaintext highlighter-rouge">firstUnchosenIndex</code> in Accept replies. If proposer’s firstUnchosenIndex &gt; firstUnchosenIndex from response, then proposer sends <code class="language-plaintext highlighter-rouge">Success</code> RPC (in background)</li>
  <li>
<code class="language-plaintext highlighter-rouge">Success(index, v)</code> notifies acceptor of chosen entry:
    <ul>
      <li>acceptedValue[index] = v</li>
      <li>Mark acceptedProposal[index] as chosen</li>
      <li>return firstUnchosenIndex</li>
      <li>Proposer sends additional Success RPCs, if needed</li>
    </ul>
  </li>
</ul>

<h3 id="client-protocol">Client protocol</h3>

<p>Clients send commands to the leader. If leader is unknown, they can contact any server, which will redirect the request to the leader. Leader responds only after the command has been chosen and executed by leader’s state machine. If the request times out, client retries the request.</p>

<p>If the leader crashes after executing the command but before responding, we must not execute command twice. The solution is to have the client embed a unique id in each command. Servers include the id in the log entry. State machine records most recent command executed for each client. Before executing command, the state machine checks to see if the command has already been executed, if so, it ignores the new command and returns the response from old command.</p>

<h3 id="configuration-changes">Configuration Changes</h3>

<p>System configurations such as ids or addresses for each server, what constitutes a majority can change over time, for reasons like replacing a failed machine, or changing in the degree of replication. The safety requirement for configuration change is that during configuration changes, it must not be possible for different majorities to choose different values for the same log entry.</p>

<p>The solution is to have the configuration stored as a log entry, and replicated just like any other log entry. Configuration for choosing entry i is determined by entry i-α, i.e. a configuration change does not take effect until α commands have been executed. During (i-α, i), multiple concurrent commands can be pending. If the change needs to be completed quickly, the client can issue no-op commands.</p>

<h2 id="materials">Materials</h2>

<ul>
  <li>
<a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-paxos.pdf">Original paper</a> by Leslie Lamport. Created in the 1980s but not published until 1998 because the reviewers didn’t like the Greek parable in the paper and he didn’t want to change it.</li>
  <li>
<a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf">Paxos Made Simple</a> is a second attempt by Leslie Lamport to explain Paxos. It is still not widely understood.</li>
  <li>
<a href="http://www.cs.utexas.edu/users/lorenzo/corsi/cs380d/papers/paper2-1.pdf">Paxos Made Live - An Engineering Perspective</a> by Google engineers sharing their experience implementing Paxos in Chubby.</li>
  <li>
<a href="https://www.youtube.com/watch?v=JEpsBg0AO6o">The Paxos lecture video</a> by John Ousterhout (author of the <a href="http://www.stanford.edu/~ouster/cgi-bin/papers/lfs.pdf">log-structured filesystem paper</a>) makes it simple.</li>
  <li>
<a href="https://paxos.systems">Paxos Made Moderately Complex</a> is an operational description of Multi-Paxos.</li>
</ul>

<h2 id="other-consensus-algorithms">Other consensus algorithms</h2>

<ul>
  <li>
<a href="https://ramcloud.stanford.edu/wiki/download/attachments/11370504/raft.pdf">RAFT</a> is an attempt at a more understandable consensus algorithm. The <a href="https://www.youtube.com/watch?v=YbZ3zDzDnrw">video presentation</a>, also by John Ousterhout, is great too.</li>
  <li>
<a href="http://pmg.csail.mit.edu/papers/vr-revisited.pdf">Viewstamped Replication</a> by Barbara Liskov is an early algorithm to directly model log replication.</li>
  <li>
<a href="http://www.stanford.edu/class/cs347/reading/zab.pdf">Zab</a> is the algorithm used by Zookeeper.</li>
</ul>


    </div>

</article>
<div class="post-nav">
<a class="previous" href="/2022/07/27/notes-how-to-speak.html" title="[notes] How to Speak">[notes] How to Speak</a><a class="next" href="/2022/09/10/utah-national-parks.html" title="Utah National Parks">Utah National Parks</a>
</div>
<!---->
    <!---->
    <!-- <div class="post-related">
      <div>Related Articles</div>
      <ul>
        <li><a class="post-link" href="/2022/09/18/raft-basics.html" title="Utah National Parks">Raft Basics</a></li><li><a class="post-link" href="/2022/12/30/extendible-hashing.html" title="Utah National Parks">Hash Schemes and Extendible Hashing</a></li><li><a class="post-link" href="/2021/10/02/yellowstone-and-grand-teton.html" title="Utah National Parks">Yellowstone and Grand Teton</a></li><li><a class="post-link" href="/2022/07/27/notes-how-to-speak.html" title="Utah National Parks">[notes] How to Speak</a></li></ul>
    </div> -->
    <!----><div class="post-comments"></div></section>
</div>


  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">TOC</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      menuHTML += (
        '<li class="h-' + h.tagName.toLowerCase() + '">'
        + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 20;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
      <div>Copyright © 2021-2023 @Minmin Jin</div>
      <div>
        <span>
          <a href="/terms_and_licensing/index.html">Terms &amp; Licensing</a>
        </span>
      </div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/atom.xml">via RSS</a>
</div>
    </div>
  </div>
</footer>
</body>
</html>
