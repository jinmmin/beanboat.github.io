<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Raft Basics | Bean Boat</title>
<meta name="generator" content="Jekyll v4.3.1">
<meta property="og:title" content="Raft Basics">
<meta name="author" content="Minmin Jin">
<meta property="og:locale" content="en_US">
<meta name="description" content="Basics of the Raft consensus algorithm.">
<meta property="og:description" content="Basics of the Raft consensus algorithm.">
<link rel="canonical" href="http://localhost:4000/2022/09/18/raft-basics.html">
<meta property="og:url" content="http://localhost:4000/2022/09/18/raft-basics.html">
<meta property="og:site_name" content="Bean Boat">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2022-09-18T00:00:00-07:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Raft Basics">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Minmin Jin"},"dateModified":"2022-09-18T00:00:00-07:00","datePublished":"2022-09-18T00:00:00-07:00","description":"Basics of the Raft consensus algorithm.","headline":"Raft Basics","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2022/09/18/raft-basics.html"},"url":"http://localhost:4000/2022/09/18/raft-basics.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="shortcut icon" href="favicon.png">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/assets/css/main.css">
  <script src="/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/atom.xml" title="Bean Boat">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/go.min.js"></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightBlock(block);
  }

  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    border-radius: 0 2px;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
</head>
<body>





































































































































<header class="site-header " role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<span class="site-brand"><a class="site-brand-inner" rel="author" href="/">
  <img class="site-favicon" title="Bean Boat" src="favicon.png" onerror="this.style.display='none'">
  Bean Boat
</a>
</span><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">
<a class="page-link" href="/">HOME</a><a class="page-link" href="/archives.html">ARCHIVES</a><a class="page-link" href="/tags.html">TAGS</a><!---->
            <!--




-->
            <!---->
            <!--<span class="page-link">

<div id="google_translate_element" style="display: none;">
</div>

<span class="ct-language">
  <ul class="list-unstyled ct-language-dropdown">
    
      <li>
        <a href="#" class="lang-select" data-lang="en">
          
          <img src="https://cdn.countryflags.com/thumbs/united-states-of-america/flag-400.png" title="English">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="fr">
          
          <img src="https://cdn.countryflags.com/thumbs/france/flag-400.png" title="French">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="zh-CN">
          
          <img src="https://cdn.countryflags.com/thumbs/china/flag-400.png" title="Chinese(Simple)">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ja">
          
          <img src="https://cdn.countryflags.com/thumbs/japan/flag-400.png" title="Japanese">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ko">
          
          <img src="https://cdn.countryflags.com/thumbs/south-korea/flag-400.png" title="Korean">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ru">
          
          <img src="https://cdn.countryflags.com/thumbs/russia/flag-400.png" title="Russian">
          
        </a>
      </li>
    
  </ul>
</span>

<script type="text/javascript">
function googleTranslateElementInit() {
  new google.translate.TranslateElement({
    pageLanguage: '',
    autoDisplay: false,
    layout: google.translate.TranslateElement.InlineLayout.VERTICAL
  }, 'google_translate_element');

  function restoreLang() {
    var iframe = document.getElementsByClassName('goog-te-banner-frame')[0];
    if (!iframe) return;

    var innerDoc = iframe.contentDocument || iframe.contentWindow.document;
    var restore_el = innerDoc.getElementsByTagName("button");

    for (var i = 0; i < restore_el.length; i++) {
      if (restore_el[i].id.indexOf("restore") >= 0) {
        restore_el[i].click();
        var close_el = innerDoc.getElementsByClassName("goog-close-link");
        close_el[0].click();
        return;
      }
    }
  }

  function triggerHtmlEvent(element, eventName) {
    var event;
    if (document.createEvent) {
      event = document.createEvent('HTMLEvents');
      event.initEvent(eventName, true, true);
      element.dispatchEvent(event);
    } else {
      event = document.createEventObject();
      event.eventType = eventName;
      element.fireEvent('on' + event.eventType, event);
    }
  }

  var googleCombo = document.querySelector("select.goog-te-combo");
  var langSelect = document.querySelector('.ct-language');
  langSelect.addEventListener('click', function(event) {
    if (!event.target) {
      return;
    }

    var selected = document.querySelector('.ct-language .ct-language-selected');
    if (selected) {
      selected.classList.remove('ct-language-selected');
    }

    var target = event.target;
    while (target && target !== langSelect ) {
      if (target.matches('.lang-select')) {
        break;
      }
      target = target.parentElement;
    }

    if (target && target.matches('.lang-select')) {
      var lang = target.getAttribute('data-lang');
      if (googleCombo.value == lang) {
        restoreLang();
      } else {
        target.parentElement.classList.add('ct-language-selected');
        googleCombo.value = lang;
        triggerHtmlEvent(googleCombo, 'change');
      }
    }

    event.preventDefault();
  });
}
</script>

<script type="text/javascript" src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
</span>-->
          </div>
        </nav>
</div>
  </div>
</header>

<script>
  (function() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;documentElement.setAttribute("data-header-transparent", "");var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  })();
</script>


























































































































































<script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    hashValue = decodeURIComponent(hashValue);
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = element.offsetTop - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('manual' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

    <div class="post-content e-content" itemprop="articleBody">

      <h2 id="intro">Intro</h2>
<p><i>
This post is mostly based on the <a href="https://www.youtube.com/watch?v=YbZ3zDzDnrw">Raft lecture</a> by John Ousterhout.
</i></p>

<p>I had a <a href="http://localhost:4000/2022/08/07/paxos-basics/">post</a> about the Paxos consensus algorithm. In this post, I would like to write about the basics of Raft, another widely used consensus algorithm.</p>

<p>Raft has the same use case as Paxos, but it is a much easier to understand algorithm. Actually the paper for Raft is named “In search of an understandable consensus algorithm”. Paxos is hard because the author gives only the necessary invariants and engineers have a lot of flexibility to do the implementation. Raft, instead, gives a step-by-step guide for how things should be done. When used as is, Raft is definitely simpler. When the use case is more complex and you need to customize certain behaviors, there is no obvious winner.</p>

<h2 id="leader-election">Leader election</h2>
<p>There are generally two approaches to consensus, leader-based and leader-less. For leader-based algorithms, at any given time, there is always one server in change, while others accept its decisions; and clients communicate with the leader. For leader-less algorithms, all servers have equal roles, and clients can contact any server.</p>

<p>Large-scale systems that have a single cluster leader typically use a separate replicated state machine to manage leader election and store configuration information that must survive leader crashes.</p>

<p>Raft uses a leader. Leader-based approaches are usually more efficient than leader-less approaches, as there are no conflicts in proposed values. With this, Raft operations can be divided into two categories: normal operations and leader changes.</p>

<p>Servers start up as followers. Followers expect to receive RPCs from leaders or candidates. Leaders must send heartbeats, i.e. empty <code class="language-plaintext highlighter-rouge">AppendEntries</code> RPCs, to maintain authority. If <code class="language-plaintext highlighter-rouge">electionTimeout</code> elapses with no RPCs, followers assume leader has crashed and start a new election. The election timeout is typically 100-500ms.</p>

<p>To start a <strong>new election</strong>, follower does the following:</p>
<ul>
  <li>Increment current term</li>
  <li>Change to candidate state</li>
  <li>Vote for itself</li>
  <li>Send <code class="language-plaintext highlighter-rouge">RequestVote</code> RPCs to all other servers, retry until either:
    <ul>
      <li>Receive votes from majority of servers: become leader, Send <code class="language-plaintext highlighter-rouge">AppendEntries</code> heartbeats to all other servers</li>
      <li>Receive RPC from valid leader: return to follower state</li>
      <li>Election timeout elapses, no one wins election: increment term, restart new election with a randomized timeout</li>
    </ul>
  </li>
</ul>

<p>Deposed leader may not be dead. For example, it might be temporarily disconnected from network, and after other servers elect a new leader, the old leader reconnects and attempts to commit log entries. Terms are used to detect stale leaders and candidates. Every RPC contains the term of the sender. If sender’s term is older, RPC is rejected, and sender reverts to follower and updates its term. If receiver’s term is older, it reverts to follower, updates its term, and then processes RPCs normally. Election updates terms of majority of servers, and prevents deposed leaders from committing new log entries.</p>

<h2 id="log-replication">Log replication</h2>
<p>Log replication is done using the following steps:</p>
<ul>
  <li>Client sends command to leader</li>
  <li>Leader appends command to its log</li>
  <li>Leader sends <code class="language-plaintext highlighter-rouge">AppendEntries</code> RPCs to followers</li>
  <li>Once new entry committed (replicated on a majority of the servers):
    <ul>
      <li>Leader passes command to its state machine, returns result to client</li>
      <li>Leader notifies followers of committed entries in subsequent <code class="language-plaintext highlighter-rouge">AppendEntries</code> RPCs</li>
      <li>Followers pass committed commands to their state machines</li>
    </ul>
  </li>
</ul>

<p>For crashed or slow followers, leader retries RPCs until they succeed. Performance-wise, for each command, only one successful RPC to any majority of servers is needed.</p>

<p>It is guaranteed that if log entries on different servers have same index and term, they store the same command, and the logs are identical in all preceding entries. If a given entry is committed, all preceding entries are also committed.</p>

<p>Consistency can be checked during the <code class="language-plaintext highlighter-rouge">AppendEntries</code> RPC call. Each <code class="language-plaintext highlighter-rouge">AppendEntries</code> RPC contains the index and term of the last log entry. If a follower does not contain a matching entry, it rejects the request. New leaders must make follower logs consistent with its own by deleting extraneous entries or filling in missing entries. To do so, leader keeps <code class="language-plaintext highlighter-rouge">nextIndex</code> for each follower, which is the index of next log entry to send to that follower and is initialized to <code class="language-plaintext highlighter-rouge">1 + leader's last index</code>. When <code class="language-plaintext highlighter-rouge">AppendEntries</code> consistency check fails, leader decrements <code class="language-plaintext highlighter-rouge">nextIndex</code> and tries again. When a follower overwrites an inconsistent entry, it deletes all subsequent entries.</p>

<h2 id="requirements">Requirements</h2>
<p>Same as Paxos, Raft also has safety and liveness requirements.</p>

<p><strong>Safety</strong></p>
<ul>
  <li>Leaders never overwrite entries in their logs.</li>
  <li>Only entries in the leader’s log can be committed.</li>
  <li>Entries must be committed before applying to state machine..</li>
</ul>

<p>To meet the safety requirements, there are several rules that we should follow.</p>
<ul>
  <li>
<strong>Election rule</strong>. During elections, candidate with logs most likely to contain all committed entries should be chosen.
    <ul>
      <li>Candidates include the index and term of last log entry in <code class="language-plaintext highlighter-rouge">RequestVote</code> RPCs</li>
      <li>Voting server v denies the vote if its log is “more complete”: <code class="language-plaintext highlighter-rouge">lastTerm(v) &gt; lastTerm(c) || (lastTerm(v) == lastTerm(c) &amp;&amp; lastIndex(v) &gt; lastIndex(c))</code>
</li>
      <li>Leader will have “most complete” log among electing majority</li>
    </ul>
  </li>
  <li>
<strong>Commitment rules</strong>. For a leader to decide an entry is committed:
    <ul>
      <li>The entry must be stored on a majority of servers</li>
      <li>At least one new entry from the leader’s term must also be stored on majority of servers</li>
    </ul>
  </li>
</ul>

<p><strong>Liveness</strong></p>
<ul>
  <li>Choose election timeouts randomly in [T, 2T]</li>
  <li>One server usually times out and wins election before others wake up</li>
  <li>Raft will be able to elect and maintain a steady leader as long as the system satisfies: <code class="language-plaintext highlighter-rouge">broadcastTime &lt;&lt; electionTimeout &lt;&lt; MTBF</code> (<code class="language-plaintext highlighter-rouge">MTBF</code> is average time between failures for a single server)</li>
</ul>

<h2 id="configuration-changes">Configuration changes</h2>
<p>System configuration refers to the id and address for each server, and  what constitutes a majority. Consensus mechanism must support changes in the configuration to replace failed machines or change degrees of replication.</p>

<p>Raft uses a 2-phase approach to handle configuration change. The intermediate phase uses joint consensus, meaning leader needs the majority of both old and new configurations for elections and commitment. Configuration change is just a log entry, which is applied immediately on receipt (committed or not). The process goes like commit old config, commit old + new, and commit new config. Once joint consensus is committed, we can begin replicating log entry using the new configuration. During the configuration change, any server from either configuration can server as leader. But if the current leader is not in the new config, it must step down once the new config is committed.</p>

<h2 id="log-compaction--snapshot">Log compaction / Snapshot</h2>
<p>Servers take snapshots independently. The leader occasionally send snapshots to followers that lag behind. Servers take snapshots when the log reaches a fixed size in bytes.</p>

<h2 id="references">References</h2>
<ul>
  <li>https://raft.github.io/</li>
  <li><a href="https://www.youtube.com/watch?v=YbZ3zDzDnrw">Raft lecture</a></li>
  <li>Diego Ongaro and John Ousterhout. 2014. In search of an understandable consensus algorithm. In Proceedings of the 2014 USENIX conference on USENIX Annual Technical Conference (USENIX ATC’14). USENIX Association, USA, 305–320.</li>
</ul>

<h2 id="appendix---raft-protocol">Appendix - Raft protocol</h2>
<h3 id="client-protocol">Client protocol</h3>
<ul>
  <li>Send commands to leader
    <ul>
      <li>If leader unknown, contact any server</li>
      <li>If the contacted server is not leader, it will redirect to leader</li>
    </ul>
  </li>
  <li>Leader does not respond until command has been logged, committed, and executed by leader’s state machine</li>
  <li>If request times out (e.g., leader crash):
    <ul>
      <li>Client reissues command to some other server</li>
      <li>Eventually redirected to new leader</li>
      <li>Retry request with new leader</li>
    </ul>
  </li>
  <li>Implementing <strong>exactly-once semantics</strong> as long as client does not crash by embedding a unique id in each command
    <ul>
      <li>Server includes id in log entry</li>
      <li>Before accepting command, leader checks its log for entry with that id</li>
      <li>If id found in log, ignore new command, return response from old command</li>
      <li>Prevents a command from being executed twice, if leader crashes after executing command, but before responding</li>
    </ul>
  </li>
</ul>

<h3 id="raft-protocol-glossary">Raft protocol glossary</h3>
<h4 id="terms">Terms</h4>
<ul>
  <li>Time divided into terms: election, normal operation under a single leader</li>
  <li>At most 1 leader per term</li>
  <li>Some terms have no leader (failed election)</li>
  <li>Terms act as a logical clock</li>
  <li>Each server maintains current term value, which increases monotonically</li>
  <li>Key role of terms: identify obsolete information</li>
</ul>

<h4 id="server-states">Server States</h4>
<ul>
  <li>
<strong>Leader</strong>: handles all client interactions, log replication. At most 1 viable leader at a time
    <ul>
      <li>Initialize <code class="language-plaintext highlighter-rouge">nextIndex</code> for each follower to <code class="language-plaintext highlighter-rouge">last log index + 1</code>
</li>
      <li>Send initial empty <code class="language-plaintext highlighter-rouge">AppendEntries</code> RPCs (heartbeat) to each follower; repeat during idle period to prevent election timeouts</li>
      <li>Accept commands from clients, append new entries to local log</li>
      <li>Whenever <code class="language-plaintext highlighter-rouge">last log index</code> &gt;= <code class="language-plaintext highlighter-rouge">nextIndex</code> for a follower, send <code class="language-plaintext highlighter-rouge">AppendEntries</code> RPC with log entries starting at <code class="language-plaintext highlighter-rouge">nextIndex</code>, update <code class="language-plaintext highlighter-rouge">nextIndex</code> if successful</li>
      <li>If <code class="language-plaintext highlighter-rouge">AppendEntries</code> fails because of log inconsistency, decrement <code class="language-plaintext highlighter-rouge">nextIndex</code> and retry</li>
      <li>Mark log entries committed if stored on a majority of severs and at least one entry from current term is stored on a majority of servers</li>
      <li>Step down if <code class="language-plaintext highlighter-rouge">currentTerm</code> changes</li>
    </ul>
  </li>
  <li>
<strong>Follower</strong>: completely passive (issues no RPCs, responds to incoming RPCs)
    <ul>
      <li>Respond to RPCs from candidates and leaders.</li>
      <li>Convert to candidate if election timeout elapses without either
        <ul>
          <li>Receiving valid <code class="language-plaintext highlighter-rouge">AppendEntries</code> RPC from the leader</li>
          <li>Granting vote to candidate</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
<strong>Candidate</strong>: used to elect a new leader
    <ul>
      <li>Increment <code class="language-plaintext highlighter-rouge">currentTerm</code>, vote for self</li>
      <li>Reset election timeout</li>
      <li>Send <code class="language-plaintext highlighter-rouge">RequestVote</code> RPCs to all other servers, wait for either:
        <ul>
          <li>Votes received from majority of servers: become leader</li>
          <li>
<code class="language-plaintext highlighter-rouge">AppendEntries</code> RPC received from new leader: step down</li>
          <li>Election timeout elapses without election resolution: increment term, start new election</li>
          <li>Discover higher term: step down</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>During normal operation, there is 1 leader and N-1 followers.</p>

<h4 id="persistent-state">Persistent State</h4>
<p>Each server persists the following to stable storage synchronously before responding to RPCs:</p>
<ul>
  <li>
<code class="language-plaintext highlighter-rouge">currentTerm</code>: latest term server has seen (initialized to 0 on first boot)</li>
  <li>
<code class="language-plaintext highlighter-rouge">votedFor</code>: candidate id that received vote in current term (or null if none)</li>
  <li>
<code class="language-plaintext highlighter-rouge">log[]</code>: log entries</li>
</ul>

<h4 id="log-entry">Log entry</h4>
<ul>
  <li>term: when entry was received by leader</li>
  <li>index: position of entry in the log</li>
  <li>command: command for state machine</li>
</ul>

<h3 id="requestvote-rpc">RequestVote RPC</h3>
<p>Invoked by candidates to gather votes.</p>
<ul>
  <li>
<strong>Arguments</strong>
    <ul>
      <li>candidateId: candidate requesting vote</li>
      <li>term: candidate’s term</li>
      <li>lastLogIndex: index of candidate’s last log entry</li>
      <li>lastLogTerm: term of candidate’s last log entry</li>
    </ul>
  </li>
  <li>
<strong>Results</strong>
    <ul>
      <li>term: currentTerm, for candidate to update itself</li>
      <li>voteGranted: true means candidate received vote</li>
    </ul>
  </li>
  <li>
<strong>Implementation</strong>
    <ol>
      <li>If term &gt; currentTerm, currentTerm = term (step down if leader or candidate)</li>
      <li>If term == currentTerm, votedFor is null or candidateId, and candidate’s log is at least as complete as local log, grant vote and reset election timeout</li>
    </ol>
  </li>
</ul>

<h3 id="appendentries-rpc">AppendEntries RPC</h3>
<p>Invoked by leader to replicate log entries and discover inconsistencies; also used as heartbeat.</p>
<ul>
  <li>
<strong>Arguments</strong>
    <ul>
      <li>term: leader’s term</li>
      <li>leaderId: so follower can redirect clients</li>
      <li>prevLogIndex: index of log entry immediately preceding new ones</li>
      <li>prevLogTerm: term of prevLogIndex entry</li>
      <li>entries[]: log entries to store (empty for heartbeat)</li>
      <li>commitIndex: last entry known to be committed</li>
    </ul>
  </li>
  <li>
<strong>Results</strong>
    <ul>
      <li>term: currentTerm, for leader to update itself</li>
      <li>success: true if follower contains entry matching prevLogIndex and prevLogTerm</li>
    </ul>
  </li>
  <li>
<strong>Implementation</strong>
    <ol>
      <li>Return if term &lt; currentTerm</li>
      <li>If term &gt; currentTerm, currentTerm = term</li>
      <li>If candidate or leader, step down</li>
      <li>Reset election timeout</li>
      <li>Return failure if log doesn’t contain an entry at prevLogIndex whose term matches prevLogTerm</li>
      <li>If existing entries conflict with new entries, delete ell existing entries starting with first conflicting entry</li>
      <li>Append any new entries not already in the log</li>
      <li>Advance state machine with newly committed entries</li>
    </ol>
  </li>
</ul>

<h3 id="installsnapshot-rpc">InstallSnapshot RPC</h3>
<p>Invoked by leader to send chunks of a snapshot to a follower. Leaders always send chunks in order.</p>
<ul>
  <li>
<strong>Arguments</strong>
    <ul>
      <li>term:  leader’s term</li>
      <li>leaderId:  so follower can redirect clients</li>
      <li>lastIncludedIndex: the snapshot replaces all entries up through and including this index</li>
      <li>lastIncludedTerm: term of lastIncludedIndex</li>
      <li>offset: byte offset where chunk is positioned in the snapshot file</li>
      <li>data[]: raw bytes of the snapshot chunk, starting at offset</li>
      <li>done: true if this is the last chunk</li>
    </ul>
  </li>
  <li>
<strong>Results</strong>
    <ul>
      <li>term: currentTerm, for leader to update itself</li>
    </ul>
  </li>
  <li>
<strong>Receiver implementation</strong>
    <ol>
      <li>Reply immediately if term &lt; currentTerm</li>
      <li>Create new snapshot file if first chunk (offset is 0)</li>
      <li>Write data into snapshot file at given offset</li>
      <li>Reply and wait for more data chunks if done is false</li>
      <li>Save snapshot file, discard any existing or partial snapshot with a smaller index</li>
      <li>If existing log entry has same index and term as snapshot’s last included entry, retain log entries following it and reply</li>
      <li>Discard the entire log</li>
      <li>Reset state machine using snapshot contents (and load snapshot’s cluster configuration)</li>
    </ol>
  </li>
</ul>


    </div>

</article>
<div class="post-nav">
<a class="previous" href="/2022/09/10/utah-national-parks.html" title="Utah National Parks">Utah National Parks</a><a class="next" href="/2022/10/18/portugal-visa.html" title="My experience of getting a Portugal visa">My experience of getting a Portugal...</a>
</div>
<!---->
    <!---->
    <!-- <div class="post-related">
      <div>Related Articles</div>
      <ul>
        <li><a class="post-link" href="/2022/06/04/atlanta-and-the-great-smoky-mountains.html" title="My experience of getting a Portugal visa">Atlanta and the Great Smoky Mountains</a></li><li><a class="post-link" href="/2021/10/02/yellowstone-and-grand-teton.html" title="My experience of getting a Portugal visa">Yellowstone and Grand Teton</a></li><li><a class="post-link" href="/2022/07/27/notes-how-to-speak.html" title="My experience of getting a Portugal visa">[notes] How to Speak</a></li><li><a class="post-link" href="/2022/07/10/one-month-into-confluent.html" title="My experience of getting a Portugal visa">One month into Confluent</a></li></ul>
    </div> -->
    <!----><div class="post-comments"></div></section>
</div>


  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">TOC</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      menuHTML += (
        '<li class="h-' + h.tagName.toLowerCase() + '">'
        + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 20;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
      <div>Copyright © 2021-2023 @Minmin Jin</div>
      <div>
        <span>
          <a href="/terms_and_licensing/index.html">Terms &amp; Licensing</a>
        </span>
      </div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/atom.xml">via RSS</a>
</div>
    </div>
  </div>
</footer>
</body>
</html>
